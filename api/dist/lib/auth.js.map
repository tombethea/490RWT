{
  "version": 3,
  "sources": ["../../src/lib/auth.js"],
  "sourcesContent": ["import { AuthenticationError, ForbiddenError } from '@redwoodjs/graphql-server'\nimport { db } from './db'\n\n/**\n * The session object sent in as the first argument to getCurrentUser() will\n * have a single key `id` containing the unique ID of the logged in user\n * (whatever field you set as `authFields.id` in your auth function config).\n * You'll need to update the call to `db` below if you use a different model\n * name or unique field name, for example:\n *\n *   return await db.profile.findUnique({ where: { email: session.id } })\n *                   \u2500\u2500\u2500\u252C\u2500\u2500\u2500                       \u2500\u2500\u252C\u2500\u2500\n *      model accessor \u2500\u2518      unique id field name \u2500\u2518\n *\n * !! BEWARE !! Anything returned from this function will be available to the\n * client--it becomes the content of `currentUser` on the web side (as well as\n * `context.currentUser` on the api side). You should carefully add additional\n * fields to the `select` object below once you've decided they are safe to be\n * seen if someone were to open the Web Inspector in their browser.\n */\nexport const getCurrentUser = async (session) => {\n  return await db.user.findUnique({\n    where: { id: session.id },\n    select: { id: true, email: true },\n  })\n}\n\n/**\n * The user is authenticated if there is a currentUser in the context\n *\n * @returns {boolean} - If the currentUser is authenticated\n */\nexport const isAuthenticated = () => {\n  return !!context.currentUser\n}\n\n/**\n * Checks if the currentUser is authenticated (and assigned one of the given roles)\n *\n * @param roles: AllowedRoles - Checks if the currentUser is assigned one of these roles\n *\n * @returns {boolean} - Returns true if the currentUser is logged in and assigned one of the given roles,\n * or when no roles are provided to check against. Otherwise returns false.\n */\nexport const hasRole = (roles) => {\n  if (!isAuthenticated()) {\n    return false\n  }\n\n  const currentUserRoles = context.currentUser?.roles\n\n  if (typeof roles === 'string') {\n    if (typeof currentUserRoles === 'string') {\n      // roles to check is a string, currentUser.roles is a string\n      return currentUserRoles === roles\n    } else if (Array.isArray(currentUserRoles)) {\n      // roles to check is a string, currentUser.roles is an array\n      return currentUserRoles?.some((allowedRole) => roles === allowedRole)\n    }\n  }\n\n  if (Array.isArray(roles)) {\n    if (Array.isArray(currentUserRoles)) {\n      // roles to check is an array, currentUser.roles is an array\n      return currentUserRoles?.some((allowedRole) =>\n        roles.includes(allowedRole)\n      )\n    } else if (typeof context.currentUser.roles === 'string') {\n      // roles to check is an array, currentUser.roles is a string\n      return roles.some(\n        (allowedRole) => context.currentUser?.roles === allowedRole\n      )\n    }\n  }\n\n  // roles not found\n  return false\n}\n\n/**\n * Use requireAuth in your services to check that a user is logged in,\n * whether or not they are assigned a role, and optionally raise an\n * error if they're not.\n *\n * @param roles: AllowedRoles - When checking role membership, these roles grant access.\n *\n * @returns - If the currentUser is authenticated (and assigned one of the given roles)\n *\n * @throws {AuthenticationError} - If the currentUser is not authenticated\n * @throws {ForbiddenError} If the currentUser is not allowed due to role permissions\n *\n * @see https://github.com/redwoodjs/redwood/tree/main/packages/auth for examples\n */\nexport const requireAuth = ({ roles }) => {\n  if (!isAuthenticated()) {\n    throw new AuthenticationError(\"You don't have permission to do that.\")\n  }\n\n  if (roles && !hasRole(roles)) {\n    throw new ForbiddenError(\"You don't have access to do that.\")\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,4BAAoD;AACpD,gBAAmB;AAmBZ,MAAMA,iBAAiB,OAAOC,YAAY;AAC/C,SAAO,MAAMC,aAAGC,KAAKC,WAAW;IAC9BC,OAAO;MAAEC,IAAIL,QAAQK;IAAd;IACPC,QAAQ;MAAED,IAAI;MAAME,OAAO;IAAnB;EAFsB,CAAnB;AAId;AAOM,MAAMC,kBAAkB,MAAM;AACnC,SAAO,CAAC,CAACC,8BAAQC;AAClB;AAUM,MAAMC,UAAWC,WAAU;;AAChC,MAAI,CAACJ,gBAAe,GAAI;AACtB,WAAO;EACR;AAED,QAAMK,oBAAmBJ,mCAAQC,gBAARD,mBAAqBG;AAE9C,MAAI,OAAOA,UAAU,UAAU;AAC7B,QAAI,OAAOC,qBAAqB,UAAU;AAExC,aAAOA,qBAAqBD;IAC7B,eAAU,gBAAAE,SAAcD,gBAAd,GAAiC;AAE1C,aAAOA,qDAAkBE,KAAMC,iBAAgBJ,UAAUI;IAC1D;EACF;AAED,UAAI,gBAAAF,SAAcF,KAAd,GAAsB;AACxB,YAAI,gBAAAE,SAAcD,gBAAd,GAAiC;AAEnC,aAAOA,qDAAkBE,KAAMC,qBAC7B,gBAAAC,SAAAL,KAAK,EAAA,KAALA,OAAeI,WAAV;IAER,WAAU,OAAOP,8BAAQC,YAAYE,UAAU,UAAU;AAExD,iBAAO,YAAAM,SAAAN,KAAK,EAAA,KAALA,OACJI,iBAAD;;AAAiBP,iBAAAA,MAAAA,8BAAQC,gBAARD,gBAAAA,IAAqBG,WAAUI;OADtC;IAGb;EACF;AAGD,SAAO;AACR;AAgBM,MAAMG,cAAc,CAAC;EAAEP;AAAF,MAAc;AACxC,MAAI,CAACJ,gBAAe,GAAI;AACtB,UAAM,IAAIY,0CAAoB,uCAAxB;EACP;AAED,MAAIR,SAAS,CAACD,QAAQC,KAAD,GAAS;AAC5B,UAAM,IAAIS,qCAAe,mCAAnB;EACP;AACF;",
  "names": ["getCurrentUser", "session", "db", "user", "findUnique", "where", "id", "select", "email", "isAuthenticated", "context", "currentUser", "hasRole", "roles", "currentUserRoles", "_Array$isArray", "some", "allowedRole", "_includesInstanceProperty", "_someInstanceProperty", "requireAuth", "AuthenticationError", "ForbiddenError"]
}
