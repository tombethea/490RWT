"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const webpack_1 = __importDefault(require("webpack"));
const path_1 = __importDefault(require("path"));
const multimatch_1 = __importDefault(require("multimatch"));
const minimatch_1 = __importDefault(require("minimatch"));
const rimraf_1 = __importDefault(require("rimraf"));
const find_cache_dir_1 = __importDefault(require("find-cache-dir"));
const find_babel_config_1 = __importDefault(require("find-babel-config"));
const utils_1 = require("../utils");
function runWebpack(config) {
    return new Promise((resolve, reject) => {
        let compiler = webpack_1.default(config);
        compiler.run((err, result) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(result);
            }
        });
    });
}
function extractPathFromIdentifier(sourceName) {
    const path = sourceName.split('!').pop();
    return path || sourceName;
}
function getOutputPath() {
    return find_cache_dir_1.default({ name: 'babel-timing' });
}
function hasExtension(name) {
    const lastPathPart = name.split('/').pop();
    if (!lastPathPart) {
        return false;
    }
    return lastPathPart.includes('.', 1);
}
async function getImports(file, options) {
    const config = getConfig(file, options);
    const stats = await runWebpack(config);
    if (stats.hasErrors()) {
        throw new Error(stats.toString('minimal'));
    }
    const outputPath = getOutputPath();
    if (outputPath) {
        rimraf_1.default(outputPath, () => { });
    }
    // https://webpack.js.org/api/stats/#root
    const importedModules = stats.toJson('normal').modules || [];
    const imports = importedModules
        .map((module) => {
        if (module.modules) {
            return module.modules.map((module) => module.identifier);
        }
        else {
            return [module.identifier];
        }
    })
        .flat()
        .filter((identifier) => identifier.startsWith('/'))
        .map(extractPathFromIdentifier)
        .filter(utils_1.onlyUnique);
    return imports;
}
exports.default = getImports;
function getConfig(file, options) {
    const babelConfig = options.babelConfig || find_babel_config_1.default.sync(path_1.default.dirname(file)).file;
    const BABEL_TIMING_FILE_EXTENSIONS_REGEX = new RegExp(`(${options.resolveExtensions.join('|')})$`);
    const config = {
        mode: 'production',
        target: 'node',
        entry: path_1.default.resolve(file),
        output: {
            path: getOutputPath(),
        },
        resolve: {
            modules: [path_1.default.join(process.cwd(), 'node_modules')],
            mainFields: options.resolveMainFields,
            extensions: options.resolveExtensions,
        },
        module: {
            rules: [
                {
                    test: BABEL_TIMING_FILE_EXTENSIONS_REGEX,
                    include: options.include.map((path) => minimatch_1.default.makeRe(path)),
                    exclude: options.exclude.map((path) => minimatch_1.default.makeRe(path)),
                    use: {
                        loader: require.resolve('babel-loader', { paths: [__dirname] }),
                        options: {
                            configFile: babelConfig,
                        },
                    },
                },
            ],
        },
        plugins: [
            new webpack_1.default.IgnorePlugin({
                // @TODO build actual absolute resource path
                checkResource(resource) {
                    // Exclude files with unexpected extensions (!options.resolveExtensions)
                    // @NOTE It breaks when filename has dots
                    if (hasExtension(resource)) {
                        return BABEL_TIMING_FILE_EXTENSIONS_REGEX.test(resource) === false;
                    }
                    // Ignore excluded files
                    const resourcePath = resource.startsWith('.')
                        ? resource
                        : require.resolve(resource, { paths: [process.cwd()] });
                    if (multimatch_1.default([resourcePath], options.exclude).length > 0) {
                        return true;
                    }
                    return false;
                },
            }),
        ],
    };
    return config;
}
