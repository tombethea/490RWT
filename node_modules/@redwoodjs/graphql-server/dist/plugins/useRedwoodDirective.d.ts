import { Plugin } from '@envelop/types';
import { DirectiveNode, DocumentNode, GraphQLFieldConfig, GraphQLResolveInfo } from 'graphql';
import { GlobalContext } from '../index';
export interface DirectiveParams<FieldType = any, DirectiveArgs = Record<string, any>> {
    root: unknown;
    args: Record<string, unknown>;
    context: GlobalContext;
    info: GraphQLResolveInfo;
    directiveNode?: DirectiveNode;
    directiveArgs: DirectiveArgs;
    resolvedValue: FieldType;
}
/**
 * Generic Type for the arguments/parameters passed to the validate function for validator directives
 *
 * You have to pass in the type of directiveArgs
 * @example ValidateArgs<{ roles?: string[] }>
 */
export declare type ValidateArgs<DirectiveArgs = Record<string, any>> = Omit<DirectiveParams<never, DirectiveArgs>, // we remove resolvedValue anyway in this type
'resolvedValue'>;
/**
 * Write your validation logic inside this function.
 * Validator directives do not have access to the field value, i.e. they are called before resolving the value
 *
 * - Throw an error, if you want to stop executing e.g. not sufficient permissions
 * - Validator directives can be async or sync
 * - Returned value will be ignored
 *
 * You have to pass in the type of directiveArgs
 * @example ValidatorDirectiveFunc<{ roles?: string[] }>
 *
 */
export declare type ValidatorDirectiveFunc<TDirectiveArgs = Record<string, any>> = (args: ValidateArgs<TDirectiveArgs>) => Promise<void> | void;
/**
 * Generic Type for the arguments/parameters passed to the transform function for transformer directives
 *
 * You have to pass in the type of directiveArgs, and the resolverValue (i.e. the type of the field you are transforming)
 * @example TransformArgs<Post, { allowedRoles: string[] }>
 */
export declare type TransformArgs<TField = any, TDirectiveArgs = Record<string, any>> = DirectiveParams<TField, TDirectiveArgs>;
/**
 * Write your transformation logic inside this function.
 * Transformer directives run **after** resolving the value
 *
 * - You can also throw an error, if you want to stop executing, but note that the value has already been resolved
 * - Transformer directives **must** be synchonous, and return a value
 *
 * You have to pass in the type of directiveArgs, and the resolverValue (i.e. the type of the field you are transforming)
 * @example TransformerDirectiveFunc<Post, { allowedRoles: string[] }>
 *
 */
export declare type TransformerDirectiveFunc<TField = any, TDirectiveArgs = Record<string, any>> = (args: TransformArgs<TField, TDirectiveArgs>) => TField;
export declare enum DirectiveType {
    VALIDATOR = "VALIDATOR_DIRECTIVE",
    TRANSFORMER = "TRANSFORMER_DIRECTIVE"
}
export declare type RedwoodDirective = ValidatorDirective | TransformerDirective;
export interface ValidatorDirective extends ValidatorDirectiveOptions {
    schema: DocumentNode;
}
export interface TransformerDirective extends TransformerDirectiveOptions {
    schema: DocumentNode;
}
interface ValidatorDirectiveOptions {
    onResolvedValue: ValidatorDirectiveFunc;
    type: DirectiveType.VALIDATOR;
    name: string;
}
interface TransformerDirectiveOptions {
    onResolvedValue: TransformerDirectiveFunc;
    type: DirectiveType.TRANSFORMER;
    name: string;
}
export declare type DirectivePluginOptions = ValidatorDirectiveOptions | TransformerDirectiveOptions;
export declare function hasDirective(info: GraphQLResolveInfo): boolean;
export declare function getDirectiveByName(fieldConfig: GraphQLFieldConfig<any, any, any>, directiveName: string): null | DirectiveNode;
export declare function isPromise(value: any): value is Promise<unknown>;
export declare type useRedwoodDirectiveReturn = Plugin<{
    onResolvedValue: ValidatorDirectiveFunc | TransformerDirectiveFunc;
}>;
export declare const useRedwoodDirective: (options: DirectivePluginOptions) => useRedwoodDirectiveReturn;
export {};
//# sourceMappingURL=useRedwoodDirective.d.ts.map